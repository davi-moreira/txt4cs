[
["index.html", "Text as Data para Ciências Sociais guia prático com aplicações Prefácio Objetivo Sobre o autor/organizador Licença Agradecimentos", " Text as Data para Ciências Sociais guia prático com aplicações Davi Moreira Criado em 02-08-2019. Atualizado em: 09-09-2020 Prefácio A partir da produção de material para o curso Text as Data: análise automatizada de conteúdo que ministrei no MQ-UFMG em 2019 e no artigo que publiquei em coautoria com Maurício Izumi (Izumi and Moreira 2018), esse livro tem como propósito difundir nas ciências sociais e humanidades técnicas e métodos de análise automatizada de conteúdo usando a linguagem R. Objetivo O principal objetivo do livro é ser tutorial prático de uso e aplicação de técnicas e métodos de análise automatizada de conteúdo na língua portuguesa através da linguagem R . Sobre o autor/organizador Davi Moreira é Professor Adjunto da Escola de Relações Internacionais da Fundação Getulio Vargas. Ph.D. em Ciência Política pela Universidade de São Paulo (USP) e vencedor do Prêmio CAPES de tese 2017 na área de Ciência Política e Relações Internacionais. Atua nas seguintes áreas: políticas públicas, estudos legislativos, métodos quantitativos em ciências sociais e análise automatizada de conteúdo. Para mais informações: Página pessoal. GitHub Google Scholar. Licença Este livro é distribuído de acordo com a licença Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (CC BY-NC-SA 4.0). Agradecimentos Agradeço aos organizadores do MQ-UFMG 2019 pela oportunidade de ministrar o curso e assim me estimular a empreender esse projeto. Também agradeço aos amigos Manoel Galdino, Rafael Magalhães, Lincon Ribeiro e Umberto Mignozzetti pelo apoio e incentivo ao longo de toda minha trajetória como cientista. Por fim, agradeço à fantástica cientista de dados Mônica Rocabado, sem a qual esse projeto continuaria na gaveta. Este livro é escrito com o uso do pacote bookdown (Xie 2019), através do R Markdown e knitr (Xie 2015). Referências "],
["intro.html", "Capítulo 1 Introdução 1.1 O R e o RStudio 1.2 O Pacote txt4cs e outros 1.3 Material de apoio", " Capítulo 1 Introdução 1.1 O R e o RStudio Com o objetivo de ser um tutorial prático de uso e aplicação de técnicas e métodos de análise automatizada de conteúdo para ciências sociais e humanidades este livro fará uso da linguagem R. R é uma linguagem de programação e também um ambiente de desenvolvimento integrado para cálculos estatísticos e gráficos. Ele pode ser facilmente instalado através do link: https://cran.r-project.org/. Para auxiliar no desenvolvimento das análises, este livro incentiva o uso do RStudio. Trata-se de um software livre de ambiente de desenvolvimento integrado (IDE) para o R1. De forma ilustrativa, o R e o RStudio operam como a figura abaixo: Com o RStudio, você estará diante do seguinte dashboard: Se está começando a usar o R para análise de dados, recomendo o seguinte material: R for Data Science; Modern Dive - Statistical Inference via Data Science; Curso R; Usando R: Um Guia para Cientistas Políticos; Em caso de dúvidas, use e abuse de fóruns como o Stackoverflow. Para aprimorar seu código e otimizar o desenvolvimento de suas análises, os guias de estilo do Google e do RStudio são ótimas referências. 1.2 O Pacote txt4cs e outros Este livro conta com o pacote txt4cs. Ele traz consigo funções específicas e bases de dados utilizadas nos exemplos apresentados. Um dos acervos de exemplo se refere ao conteúdo proferido em 17 de abril de 2016, dia de aprovação do impeachment da então Presidenta Dilma Rousseff na Câmara dos Deputados. Figure 1.1: Fonte: Empresa Brasil de Comunicação - EBC Para instalação, use os comandos abaixo: if(require(devtools) == F) install.packages(&#39;devtools&#39;); require(devtools); devtools::install_github(&quot;davi-moreira/txt4cs-pkg&quot;) require(txt4cs) Ademais, os seguintes pacotes são essenciais para o desenvolvimento da análise automatizada de conteúdo com o R. Conforme forem necessários, serão apresentados no livro. install.packages(&quot;tidyverse&quot;) install.packages(&quot;stringr&quot;) install.packages(&quot;quanteda&quot;) install.packages(&quot;readtext&quot;) install.packages(&quot;stringi&quot;) install.packages(&quot;tm&quot;) 1.3 Material de apoio Este livro não é feito do zero e resulta de inspiração em diferentes fontes. As principais são: 1.3.1 Referências para processamento de sequências de caracteres com o R Handling and Processing Strings in R e Handling Strings with R R Wikibook: Programming and Text Processing stringr: modern, consistent string processing 1.3.2 Referências em análise de conteúdo com o R: Quanteta Tutorials Text Mining with R IDE, do inglês Integrated Development Environment, é um programa de computador que reúne características e ferramentas de apoio ao desenvolvimento de software com o objetivo de agilizar este processo.↩ "],
["tada.html", "Capítulo 2 Text as data: o texto como dado 2.1 Panorama da área 2.2 Oportunidades 2.3 Quadro geral de metodologias 2.4 O processo de análise do texto como dado", " Capítulo 2 Text as data: o texto como dado 2.1 Panorama da área A análise de conteúdo possui grande relevância para as ciências sociais. Contudo, sua abordagem manual sempre limitou o volume de documentos sob análise. São raros os projetos como o Manifesto Research Group que, desde os anos 1970, analisa a ênfase temática de manifestos partidários ou o Comparative Agendas Project, que coleta e analisa dados sobre agendas de políticas públicas em diferentes países. O avanço tecnológico e científico permitiu que técnicas automatizadas de análise do conteúdo fossem desenvolvidas e aplicadas de forma simples a grandes acervos. Este avanço não foi realizado sem a contribuição das ciências sociais. Só a Political Analysis, principal revista de métodos em ciência política, possui dois special issues dedicados ao tema (Special Issue, Virtual Issue). 2.2 Oportunidades Com o desenvolvimento de métodos para análise automatizada de conteúdo, hoje o leque de oportunidades as ciências sociais é diverso e promissor. Agora, é possível: Analisar grandes acervos de forma ágil e barata, otimizando o trabalho do pesquisador. Figure 2.1: Biblioteca Florestan Fernandes - FFLCH - USP Pesquisar novos acervos para inferir o conteúdo presente e assim guiar pesquisas através de atalhos informacionais. Figure 2.2: Acervo da CIA: https://www.cia.gov/library/readingroom/advanced-search-view Analisar processos políticos contemporâneos. Figure 2.3: Trecho de fala do Deputado Federal Glauber Braga (PSOL-RJ) durante seu voto no processo de impeachment da então Presidenta da República Dilma Rousseff em 2016. Redes sociais. Figure 2.4: Foto de Pedro Ladeira, Folha de São Paulo, maio de 2019. Fake news! Olhar o passado com as lentes do presente. Questões que antes não podiam ser enunciadas agora podem ser respondidas! Processos políticos conhecidos podem ganhar novas interpretações através do uso de métodos e técnicas contemporâneas de análise automatizada de conteúdo. Figure 2.5: Liberdade Guiando o Povo - Eugène Delacroix - 1830 Contribuir socialmente: Retórica Parlamentar - Projeto experimental desenvolvido no primeiro Hackathon da Câmara dos Deputados em 2013 por Davi Moreira, Manoel Galdino e Luis Carli. Posteriormente incubado pelo Laboratório Hacker da Câmara dos Deputados. 2.3 Quadro geral de metodologias Dada a complexidade da linguagem, o processo de geração, produção e seleção de dados que resultam na comunicação humana é ainda um mistério para a ciência (Izumi and Moreira 2018; Grimmer and Stewart 2013). Logo, modelos estatísticos desenvolvidos falham na tarefa de prover um relato preciso do processo de geração de dados utilizados na produção de conteúdo e, principalmente, em seu significado. Os modelos de análise de conteúdo, portanto, não devem ser avaliados pelo quanto explicam do processo de geração dos dados. Transformar palavras em números não substitui a leitura cuidadosa e atenta de documentos. Reconhecendo que “métodos de análise automatizada de conteúdo são modelos incorretos de linguagem” (Grimmer and Stewart 2013, 2), a performance de qualquer método automatizado não é garantida sem a consideração de ao menos quatro princípios: Todos os modelos quantitativos de análise de conteúdo estão errados, mas alguns são úteis; Métodos quantitativos de análise de conteúdo amplificam a capacidade humana, mas não a substitui; Não há um método global para a análise automatizada de conteúdo; Validar, validar, validar. A escolha do modelo, da família de modelos ou de eventuais combinações a serem utilizadas é resultado dos objetivos almejados. Há uma variedade de modelos disponíveis e nenhum deles se sobrepõe aos demais. Além de estatísticas e outras informações que podem ser obtidas através da mineração do texto enquanto dados, nesse livro será dado foco aos métodods de escalonamento e classificação de conteúdo. Assim, como indicado pelo quadro de Grimmer e Stewart (2013) métodos de análise supervisionada e não supervisionada serão abordados. Figure 2.6: Quadro geral de metodologias para análise automatizada de conteúdo (Grimmer e Stewart, 2013) 2.4 O processo de análise do texto como dado O processo de trabalho para análise quantitativa de texto é muito similar a qualquer tipo de fluxo de trabalho para análise de dados em geral. Como indicado no livro Text Mining with R: a tidy approach (Silge and Robinson 2017), o seguinte fluxograma será adotado nesse livro: Figure 2.7: Fonte: Text Mining with R Referências "],
["regex.html", "Capítulo 3 R e o Processamento de Linguagem Natural 3.1 Encoding - Codificação de caracteres 3.2 Encoding para remover acentos", " Capítulo 3 R e o Processamento de Linguagem Natural O processamento de linguagem natural (NLP) é um subcampo da ciência da computação relacionado às interações entre computadores e a linguagem humana. O R dispõe de uma série de pacotes dedicados a essa área e apresenta grande potencial ao conectar o processamento de linguagem natural a todo seu arcabouço de pacotes estatísticos2. 3.1 Encoding - Codificação de caracteres Um repertório de caracteres é representado por algum tipo de sistema de codificação ( Wiki ). Exemplo comum de sistema de codificação é o código Morse que codifica as letras do alfabeto latino e os numerais como sequências de pulsos elétricos de longa e curta duração. Outro exemplo é o sistema de codificação UTF-8, capaz de codificar todos os 1.112.064 pontos de código válidos em Unicode usando até 8 bits. O R fornece funções para lidar com diferentes sistemas de codificação. Isso é útil se você lida com arquivos de texto que foram criados com outro sistema operacional e especialmente se o idioma não for o inglês e tiver muitos acentos e caracteres específicos. Por exemplo, o esquema de codificação padrão no Linux é UTF-8, enquanto o esquema de codificação padrão no Windows é Latin1. A função Encoding() retorna a codificação de uma sequência de caracteres. Por sua vez, a função iconv() é usado para converter a codificação. Vejamos um exemplo de identificação do encoding de uma sequência de caracteres: chr &lt;- &quot;olê, olê, olê, olá, Lula, Lula&quot; Encoding(chr) &lt;- &quot;UTF-8&quot; Encoding(chr) ## [1] &quot;UTF-8&quot; Utilizando o resultado do código do bloco acima, vamos agora converter o sistema de codificação para Latin1: chr &lt;- iconv(chr, from = &quot;UTF-8&quot;, to = &quot;latin1&quot;) Encoding(chr) ## [1] &quot;latin1&quot; Para conhecer a lista de sistemas de codificação de seu computador, use a função iconvlist(). 3.2 Encoding para remover acentos Conhecer o sistema de codificação e como utilizá-lo é útil se você lida com arquivos de texto criados com outro sistema operacional e/ou em idiomas que utilizam acentos e caracteres específicos. A depender da análise que deseja fazer, pode ser do seu interesse remover os acentos de uma sequência de caracteres. Nesse caso, vejamos um exemplo com o uso do pacote stringi: library(stringi) chr &lt;- &quot;olê, olê, olê, olá, Lula, Lula&quot; stri_trans_general(chr, &quot;Latin-ASCII&quot;) ## [1] &quot;ole, ole, ole, ola, Lula, Lula&quot; No exemplo acima, removemos os acentos da sequência de caracteres utilizando o American Standard Code for Information Interchange - ASCII. Se desejar uma solução caseira, o pacote txt4cs, que acompanha o livro, possui a função remove_accent(). Abaixo a sua aplicação: library(txt4cs) chr &lt;- &quot;olê, olê, olê, olá, Lula, Lula&quot; remove_accent(chr) Este capítulo tem inspiração nesse Wikibook.↩ "],
["stringR.html", "Capítulo 4 Strings no R 4.1 Strings e vetores 4.2 Strings e matrizes 4.3 Strings e data.frames 4.4 Strings e listas 4.5 Processamento básico 4.6 O pacote stringr 4.7 Regular Expressions no R", " Capítulo 4 Strings no R Na ciência da computação chamamos uma sequência de caracteres de string. Para o desenvolvimento de análises automatizadas de conteúdo, é necessário saber como processar esse tipo especial de dado (o texto como dado)3. Nesse sentido, três coisas são importantes de serem lembradas aqui: Computadores não interpretam letras. No limite, todos os caracteres são transformados em sequências compostas por zeros e uns. Logo, é através de padrões que caracteres são interpretados e os computadores armazenam os dados que retornam a nossos olhos. Programar é escrever! Não é à toa que chamamos as formas de escrita em programação de linguagens de programação. Nesse livro, por exemplo, usamos a linguagem R. Sabendo disso, o desafio de se trabalhar com o texto como dado é o desafio de fazer com que o computador diferencie código escrito do &quot;texto como dado&quot; que ele precisará processar de acordo com os interesses do analista. Como nós brasileiros lemos, o código e texto é processado pelo computador no seguinte sentido: da esquerda para a direita e de cima para baixo. Logo, ao desenvolver seu script é importante ter atenção em relação à ordem de escrita para que o computador possa desempenhar corretamente suas tarefas. É possível utilizar toda a versatilidade de estruturas de dados no R (vetores, matrizes, listas, data.frame, etc.) para processar sequências de caracteres. Como trabalhar com strings no R, portanto? 4.1 Strings e vetores Para declarar uma string, utilizamos aspas simples ' ou aspas dupla &quot;&quot;“. Vejamos o caso dos dois vetores abaixo, ambos recebendo a letra”a&quot;. # Vetores de caracteres caracter1 &lt;- &quot;a&quot; caracter2 &lt;- &#39;A&#39; class(caracter1) ## [1] &quot;character&quot; class(caracter2) ## [1] &quot;character&quot; Ambos são da classe character. 4.1.1 O R é case sensitive O R diferencia letras maiúsculas de letras minúsculas. Se compararmos os dois objetos criados acima, temos: caracter1 == caracter2 ## [1] FALSE 4.1.2 Sequências de caracteres # string txt &lt;- &quot;uma string é uma sequência de caracteres&quot; txt &lt;- &#39;também pode ser utilizada com aspas simples&#39; txt &lt;- &quot;no caso de aspas dupla, usa-se &#39;aspas simples&#39; na string&quot; txt &lt;- &#39;no caso de aspas simples, usa-se &quot;aspas dupla&quot; na string&#39; txt &lt;- &quot;para usar \\&quot;aspas dupla\\&quot; na string é necessário usar \\\\&quot; cat(txt) ## para usar &quot;aspas dupla&quot; na string é necessário usar \\ O R armazena a sequência de caracteres conforme ela é apresentada. Porém, é possível fazer uso de caracteres especiais para que o computador interprete e apresente o texto de forma adequada. Como vimos acima, o objeto txt armazena a string conforme foi redigida, mas com o uso da função cat() podemos apresentá-lo de forma adequada. Perceba a diferença entre o resultado e a sequência de caracteres que, de fato, foi armazenada no objeto txt. 4.1.3 Operações básicas com vetores de strings É possível declarar um vetor de caracteres vazio. # vetor de caracteres com 5 strings vazias palmeiras &lt;- character(5) palmeiras ## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; Vejamos seu tamanho: length(palmeiras) # verificando o tamanho do vetor ## [1] 5 Vemos que o objeto palmeiras possui 5 elementos, todos sem qualquer conteúdo, mas da classe character. Será que é possível inserir conteúdo em elementos específicos do vetor? Vejamos: # incluindo string no primeiro e terceiro elementos do vetor palmeiras[1] &lt;- &quot;Quando surge o alviverde imponente&quot; palmeiras[3] &lt;- &quot;Sabe bem o que vem pela frente&quot; palmeiras ## [1] &quot;Quando surge o alviverde imponente&quot; &quot;&quot; ## [3] &quot;Sabe bem o que vem pela frente&quot; &quot;&quot; ## [5] &quot;&quot; Ótimo! Significa que podemos ter um vetor no com o Hino do Palmeiras, sendo cada um de seus elementos um verso dessa bela poesia. E seria possível ter um vetor cujos elementos fossem os hinos (sequências de caracteres/strings) de todos os times do país? Sim! 4.1.3.1 Atenção Um vetor com uma string vazia é diferente de um vetor sem strings # Atenção: str_vazia &lt;- &quot;&quot; # string vazia char_vazio &lt;- character(0) # caracter vazio length(str_vazia) ## [1] 1 length(char_vazio) ## [1] 0 4.1.4 Caracteres e outros tipos de dados É importante saber como o R processa o texto como dado (character) em conjunto com outros formatos. frase &lt;- &quot;Campeonatos Brasileiros vencidos pelo Palmeiras.&quot; is.numeric(frase) ## [1] FALSE is.character(frase) ## [1] TRUE Acima verificamos que a classe do objeto frase é de tipo character. quantidade &lt;- 5 + 5 quantidade ## [1] 10 is.numeric(quantidade) ## [1] TRUE is.character(quantidade) ## [1] FALSE Acima verificamos que a classe do objeto quantidade é de tipo numeric. Seria possível converter de um tipo para outro? # convertendo quantidade quantidade &lt;- as.character(quantidade) quantidade ## [1] &quot;10&quot; is.character(quantidade) ## [1] TRUE Sim! Veja que agora o valor 10 aparece entre aspas, pois o objeto quantidade foi convertido para a classe character. E se um vetor possuir números e caracteres em diferentes elementos, como o R interpreta a classe desse vetor? # vetor com números e strings brasileiros &lt;- c(10, &quot;Campeonatos Brasileiros vencidos pelo Palmeiras.&quot;) brasileiros ## [1] &quot;10&quot; ## [2] &quot;Campeonatos Brasileiros vencidos pelo Palmeiras.&quot; class(brasileiros) ## [1] &quot;character&quot; Perceba que o vetor é declarado com o número 10 no primeiro elemento e uma string no segundo elemento. Contudo, o R adota um critério de coerção de dados para que o vetor seja da classe character. Por isso, o número 10 é automaticamente convertido como caracter. O R segue duas regras básicas de coerção de tipos de dados: Se uma cadeia de caracteres estiver presente em um vetor, todo o resto do vetor será convertido em cadeias de caracteres. Se um vetor tiver apenas elementos lógicos e números, os elementos lógicos serão convertidos em números; Valores TRUE se tornam 1 e os valores FALSE se tornam 0. 4.2 Strings e matrizes No R matrizes são estruturas de dados que suportam apenas um tipo de classe de dados. Logo, assim como no caso do vetor visto anteriormente, ao constatar a presenção de alguma entrada de classe character automaticamente todos os elementos da matriz são convertidos. # Matrizes ---- m &lt;- rbind(c(1:5), letters[1:5]) m ## [,1] [,2] [,3] [,4] [,5] ## [1,] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; ## [2,] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; class(m) ## [1] &quot;matrix&quot; 4.3 Strings e data.frames data.frames são as estruturas de dados mais utilizadas no R. Sua versatilidade permite ter no mesmo objeto dados de classes diferentes num formato de matriz (matriz de dados). Vejamos: # Data Frames ---- df1 &lt;- data.frame(numeros = 1:5, letras = letters[1:5]) str(df1) ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ numeros: int 1 2 3 4 5 ## $ letras : Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5 Como padrão da função data.frame() strings são transformadas em fatores. Para manter strings como caracteres deve-se usar o argumento: stringsAsFactors = FALSE. df1 &lt;- data.frame(numeros = 1:5, letras = letters[1:5], stringsAsFactors = FALSE) str(df1) ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ numeros: int 1 2 3 4 5 ## $ letras : chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... 4.4 Strings e listas Das estruturas de objetos mais populares no R, listas são as mais complexas. Sua grande vantagem em relação às demais estruturas é permitir uma organização hierárquica dos dados independente de sua classe e tamanho. Vejamos um exemplo: # Listas ---- # listas contemplam qualquer tipo de estrutura de dados ls &lt;- list(1:10, letters[1:5], rnorm(5), m) ls ## [[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## [[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; ## ## [[3]] ## [1] 1.6761413 0.8539556 -0.3075357 0.9296786 -1.6628656 ## ## [[4]] ## [,1] [,2] [,3] [,4] [,5] ## [1,] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; ## [2,] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; No exemplo acima, o objeto ls é composto por quatro elementos que contêm, cada um, diferentes tamanhos e diferentes estruturas de dados. 4.5 Processamento básico 4.5.1 Contando caracteres A função nchar() é um forma ágil e fácil de se obter o número de caracteres de uma string ou de strings de um vetor. nchar(c(&quot;Quantos&quot;, &quot;caracteres?&quot;)) ## [1] 7 11 nchar(&quot;Quantos caracteres?&quot;) ## [1] 19 No exemplo acima, perceba que a função contabiliza o espaço entre palavras como caracter. Por isso, a soma do total de caracteres do primeiro caso (\\(7 + 11 = 18\\) caracteres) não é igual ao total de caracteres do segundo (\\(19\\) caracteres). 4.5.2 toupper(), tolower() Sendo o R case sensitive, para o processamento do texto como dado, pode ser de interesse do pesquisador harmonizar o conteúdo sob análise com o objetivo de ter todos os caracteres em formato maiúsculo ou minúsculo. As funções toupper() e tolower() desempenham bem esse papel. tolower(c(&quot;TUdo eM MinúsCuLA&quot;, &quot;ABCDE&quot;)) ## [1] &quot;tudo em minúscula&quot; &quot;abcde&quot; toupper(c(&quot;TUdo eM mAiúsCula&quot;, &quot;ABCDE&quot;)) ## [1] &quot;TUDO EM MAIÚSCULA&quot; &quot;ABCDE&quot; 4.5.2.1 Recortando strings: substr(), substring(). Para o processamento do texto como dado, também pode ser de interesse do pesquisador a seleção de trechos de uma sequência de caracteres. Isso pode ser facilmente feito com as funções substr() e substring() indicando como parâmetros a posição nas quais a string deve ser recortada. substr(&quot;O Palmeiras é o time da virada, o Palmeiras é o time do amor.&quot;, 1, 30) ## [1] &quot;O Palmeiras é o time da virada&quot; substring(&quot;O Palmeiras é o time da virada, o Palmeiras é o time do amor.&quot;, 33, 60) ## [1] &quot;o Palmeiras é o time do amor&quot; 4.5.2.2 União, Intersecção, Diferença, Igualdade Operações com vetores de forma geral podem ser aplicadas a vetores com strings. Podemos, por exemplo, unir diferentes vetores. # União vec1 &lt;- c(&quot;algumas&quot;, &quot;palavras&quot;, &quot;aleatória&quot;, &quot;aqui&quot;) vec2 &lt;- c(&quot;e&quot;, &quot;algumas&quot;, &quot;palavras&quot;, &quot;ali&quot;) union(vec1, vec2) ## [1] &quot;algumas&quot; &quot;palavras&quot; &quot;aleatória&quot; &quot;aqui&quot; &quot;e&quot; &quot;ali&quot; Verificar a intersecção entre dois vetores. # Intersecção intersect(vec1, vec2) ## [1] &quot;algumas&quot; &quot;palavras&quot; Verificar a diferença entre dois vetores. # Diferença setdiff(vec1, vec2) ## [1] &quot;aleatória&quot; &quot;aqui&quot; E a igualdade de elementos entre dois vetores. No caso, entre o vetor vec1 e ele mesmo. # Igualdade identical(vec1, vec1) ## [1] TRUE 4.5.2.3 Elemento contido em Outra operação básica de interesse é a verificação se um elemento (no caso, uma sequência de caracteres) está contido num objeto. Vamos verificar abaixo se a sequência “aqui” está contida no vetor vec1 através do operador %in%. # Elemento contido em ---- elem &lt;- &quot;aqui&quot; elem %in% vec1 ## [1] TRUE É importante destacar que o exemplo acima é uma operação básica de vetores no R e não exclusiva para sequência de caracteres. Nesse sentido, ela apenas checa se no vetor vec1 há algum elemento idêntico ao padrão “aqui”. Mais adiante verificaremos como identificar a presença de sequências de caracteres no interior de outras strings sem que tenham de ser idênticas. 4.5.2.4 Ordenação É possível ordenar um vetor de strings em ordem alfabética ou em sentido oposto como no exemplo abaixo. Tal versatilidade pode ser útil para o ordenamento de uma matriz de dados completa com base numa variável de nomes, por exemplo. # Ordenando ---- sort(vec1, decreasing = TRUE) ## [1] &quot;palavras&quot; &quot;aqui&quot; &quot;algumas&quot; &quot;aleatória&quot; 4.6 O pacote stringr O pacote stringr integra uma coleção de pacotes projetados para a ciência de dados, o tidyverse. Combinado ao pacote stringi, você terá acesso a praticamente todas as possíveis funções necessárias para o processamento de strings em mais alto nível. Existem quatro famílias principais de funções no stringr: Manipulação de caracteres: essas funções permitem que você manipule caracteres individuais dentro de sequências de caracteres. Ferramentas de espaço em branco para adicionar, remover e manipular espaços. Operações sensíveis à localização geográfica, cujas operações irão variar de local para local. Funções de correspondência de padrões, sendo o mais comum as expressões regulares. Além do que veremos neste material, é altamente recomendável a consulta ao capítulo sobre strings do R for Data Science. # carregando pacote ---- library(stringr) 4.6.1 Verificando o tamanho de uma string4 str_length(&quot;O Palmeiras é o time da virada, o Palmeiras é o time do amor.&quot;) ## [1] 61 4.6.2 Identificando caracter numa posição específica. # vetor de strings txt &lt;- c(&quot;O Palmeiras é o time da virada&quot;, &quot;o Palmeiras é o time do amor.&quot;) Selecionando o terceiro caracter. # identificando terceira letra str_sub(txt, 3, 3) ## [1] &quot;P&quot; &quot;P&quot; Selecionando do segundo caracter de trás pra frente. str_sub(txt, 2, -2) ## [1] &quot; Palmeiras é o time da virad&quot; &quot; Palmeiras é o time do amor&quot; 4.6.3 Incluindo caracter ou string numa posicao específica. str_sub(txt, 3, 11) &lt;- &quot;PALMEIRAS&quot; txt ## [1] &quot;O PALMEIRAS é o time da virada&quot; &quot;o PALMEIRAS é o time do amor.&quot; Preencher uma string em tamanho fixo. str_pad(txt, 50) # por padrão: left ## [1] &quot; O PALMEIRAS é o time da virada&quot; ## [2] &quot; o PALMEIRAS é o time do amor.&quot; Remove espaço extra. txt &lt;- str_pad(txt, 50) # por padrão: left str_trim(txt) ## [1] &quot;O PALMEIRAS é o time da virada&quot; &quot;o PALMEIRAS é o time do amor.&quot; 4.6.4 Recortando uma string para obter parte da sequência de caracteres. str_sub(txt, start = 3, end = 11) ## [1] &quot; &quot; &quot; &quot; É possível fazer o recorte usando índices de trás pra frente. str_sub(txt, start = -14, end = -1) ## [1] &quot;time da virada&quot; &quot; time do amor.&quot; Extração de palavras. word(txt, 2) ## [1] &quot;&quot; &quot;&quot; word(txt, -1) ## [1] &quot;virada&quot; &quot;amor.&quot; 4.7 Regular Expressions no R Até aqui você viu funções básicas e intermediárias para o processamento de sequências de caracteres no R. Para avançar, é necessário aprender o uso de expressões regulares ( Regular Expressions ). Como definido no livro Handling Strings with R, uma expressão regular é um conjunto de símbolos que descreve um padrão de texto. Mais formalmente, uma expressão regular é um padrão que descreve um conjunto de cadeias de caracteres. Como o termo “expressão regular” é bastante longo, a maioria das pessoas usa a palavra regex para se referir à área. Entre outras tarefas, o uso de expressões regulares pode ajudá-lo a (Wickham and Grolemund 2017): Determinar cadeias de caracteres correspondentes a um padrão. Encontrar as posições de padrões correspondentes. Extrair o conteúdo de padrões correspondentes. Substituir o padrão correspondente por novos valores. Dividir uma sequência com base na correspondência de um padrão determinado. No entanto, é preciso ter atenção, pois o uso de expressões regulares pode se tornar uma tarefa realmente complexa. Veja esta discussão do StackOverflow a respeito de seu uso para identificação de endereços de e-mail, por exemplo. Dada a complexidade que a área pode assumir, vamos verificar o uso das regex em algumas funções do pacote stringr com base nesse tutorial. Junto a ele, é recomendável que a leitura atenta do ?regex no R. 4.7.1 Identificação e Extração de padrão txt &lt;- c(&quot;O Palmeiras é o time da virada&quot;, &quot;o Palmeiras é o time do amor.&quot;) str_extract(txt, &quot;amor&quot;) ## [1] NA &quot;amor&quot; str_detect(txt, &quot;amor&quot;) ## [1] FALSE TRUE Utilizando o operador | (“OU”): str_detect(c(&quot;presidente&quot;, &quot;presidencialismo&quot;, &quot;presidencialista&quot;, &quot;parlamentarismo&quot;), &quot;ente|ismo&quot;) ## [1] TRUE TRUE FALSE TRUE str_extract(c(&quot;presidente&quot;, &quot;presidencialismo&quot;, &quot;presidencialista&quot;, &quot;parlamentarismo&quot;), &quot;ente|ismo&quot;) ## [1] &quot;ente&quot; &quot;ismo&quot; NA &quot;ismo&quot; str_extract(c(&quot;presidente&quot;, &quot;presidencialismo&quot;, &quot;presidencialista&quot;, &quot;parlamentarismo&quot;), &quot;(presidencial|parlamentar)ismo&quot;) ## [1] NA &quot;presidencialismo&quot; NA &quot;parlamentarismo&quot; Usar o “.” corresponde a qualquer caracter exceto uma nova linha: txt &lt;- c(&quot;presidente&quot;, &quot;presidencialismo&quot;, &quot;presidencialista&quot;, &quot;parlamentarismo&quot;) str_extract(txt, &quot;..a.....&quot;) ## [1] NA &quot;cialismo&quot; &quot;cialista&quot; &quot;rlamenta&quot; Para identificar o “.” de fato, usamos “\\.”. Para poder usar a “\\”, adicionamos mais uma e temos: txt &lt;- c(&quot;O Palmeiras é o time da virada&quot;, &quot;o Palmeiras é o time do amor.&quot;) str_detect(txt, &quot;\\\\.&quot;) ## [1] FALSE TRUE Para identificar a “\\” de fato, usamos “\\\\”: txt &lt;- c(&quot;O Palmeiras é o time da virada \\\\ o Palmeiras é o time do amor.&quot;) writeLines(txt) ## O Palmeiras é o time da virada \\ o Palmeiras é o time do amor. str_detect(txt, &quot;\\\\.&quot;) ## [1] TRUE 4.7.2 Substituição txt &lt;- c(&quot;O Palmeiras é o time da virada&quot;, &quot;o Palmeiras é o time do amor.&quot;) str_replace(txt, &quot;Palmeiras&quot;, &quot;PALMEIRAS&quot;) ## [1] &quot;O PALMEIRAS é o time da virada&quot; &quot;o PALMEIRAS é o time do amor.&quot; 4.7.3 Âncoras Por padrão, expressões regulares buscam por correspondência em qualquer parte de uma sequência de caracteres. Porém, é extremamente útil poder ancorar a busca pela correspondência no início ou no final de uma string. Podemos usar: “^” para coincidir com o início da string. “$” para coincidir com o final da string. txt &lt;- c(&quot;O Palmeiras é o time da virada&quot;, &quot;o Palmeiras é o time do amor.&quot;) str_detect(txt, &quot;^O&quot;) ## [1] TRUE FALSE str_detect(txt, &quot;\\\\.$&quot;) ## [1] FALSE TRUE Referências "],
["scrape.html", "Capítulo 5 Obtenção de conteúdo 5.1 word, excel ou .pdf 5.2 Webscraping 5.3 Web Services 5.4 Download de arquivos da web 5.5 Twitter 5.6 Imagens 5.7 Áudio Transcrição", " Capítulo 5 Obtenção de conteúdo Davi Moreira, Mônica Rocabado \\(~\\) Uma das tarefas mais importantes para a análise de conteúdo consiste na sua própria busca e aquisição. O R nos ajuda nessa tarefa a partir de distintas estratégias. A seguir apresento aquelas nas quais o uso de técnicas computacionais e programação potencializa o alcance e escala de acervos a serem utilizados para pesquisas. 5.1 word, excel ou .pdf Caso tenha realizado surveys com perguntas abertas ou possua conteúdo de texto organizado em formato de documento ou tabulado é possível utilizar o R para analisá-las. Para arquivos em formato excel pode-se usar o pacote readxl com a função read_excel, funciona de forma similar ao exemplo em de leitura de arquivos em .csv. Para leitura de arquivos .txt, .csv, entre outros, recomenda-se utilizar o pacote readr. Vejamos um exemplo: 5.1.1 .xlsx SPLegis A Câmara dos Vereadores de São Paulo publica dados de sua atividade no portal SPLegis. Entre as informações disponíveis, é possível obter relatórios dos projetos com o conteúdo de todas as ementas através do download de um arquivo em formato .xlsx! library(readxl) arquivo_excel &lt;- read_excel(&quot;Emendas Apresentadas.xlsx&quot;) 5.1.2 .pdf e .doc Antes de achar que os dados de um arquivo .pdf ou .doc são um obstáculo para a abordagem do texto como dado, diferentes estratégias podem ser adotadas para sua obtenção e processamento. Com o uso do pacote textreadr, por exemplo, de forma simples pode-se transformar o conteúdo do arquivo .pdf num arquivo .txt. Vejamos o conteúdo do discurso de posse do ex-presidente Luis Inácio Lula da Silva realizado em 01 de janeiro de 2003 no Congresso Nacional: library(textreadr) # lendo arquivo .pdf txt &lt;- read_document(&quot;https://raw.githubusercontent.com/davi-moreira/txt4cs/master/data/lula-pronunciamento-posse-cd-2003.pdf&quot;) # salvando como .txt writeLines(txt, &quot;lula-pronunciamento-posse-cd-2003.txt&quot;) 5.2 Webscraping O Webscraping consiste na possibilidade de uso de programação para raspagem de dados da web, ou seja a obtenção de conteúdo presente na web. Nesse sentido, suponha que ao invés de montar uma equipe que irá acessar páginas na web para coletar seu conteúdo, você desenvolverá um programa específico para realizar essa tarefa com foco sobre os objetivos de sua pesquisa. 5.2.1 Pacotes para raspagem de dados Há diversos pacotes para raspagem de dados com o R. Abaixo segue um lista com os principais. Para referências sobre seu uso, consulte os links indicados, este tutorial sobre o rvest e este capitulo sobre web scraping. httr xml2 rvest Como o site Curso-R destaca, esses pacotes não são suficientes para acessar todo tipo de conteúdo da web. Páginas com conteúdo produzido na linguagem javascript, por exemplo, precisam de outras ferramentas para acesso a seu conteúdo. Nesses casos, é necessário “simular” um navegador que acessa a página web e realiza consultas. Uma das melhores ferramentas para isso é o selenium, abaixo indicado. RSelenium 5.2.2 Etapas para raspagem de dados na web O processo de raspagem dos dados consiste nas seguintes etapas: Etapa 1: Conhecer detalhadamente o caminho para acesso aos dados Qual o caminho que um usuário necessita realizar para obter os dados? É necessário preencher um formulário ou assinalar um Recapctha? Etapa 2: Armazenar todos os caminhos de acesso aos dados de forma amigável ao programa Caso exista um caminho para obter esse dado, deve ser registrado Não é necessário realizar esse procedimento em todos as páginas que for realizar, mas é desejável. Etapa 3: Obter os dados: raspagem de fato Etapa 4: Processar os dados obtidos 5.2.3 Código fonte Toda página na internet possui um código-fonte - muitas vezes em html - que indica e cria o conteúdo de forma visual para página. Ao clicar na página desejada com o botão direito do mouse e selecionar “código fonte” ou digitar CRTL + U, pode-se visualizá-lo. Vejamos um exemplo: Câmara dos Deputados Ao acessar o código fonte dessa página do portal da Câmara dos Deputados, você consegue visualizar o código .html que produz toda visualização, incluindo o conteúdo do discurso proferido pelo então deputado Jair Bolsonaro em 17 de Agosto de 20105. 5.2.4 Obtenção de Código Fonte - Exemplo: Se é possível visualizar o conteúdo, é possível obtê-lo de forma automatizada. Vamos, portanto, obter o conteúdo do discurso proferido pelo então deputado Jair Bolsonaro em 17 de Agosto de 20106. Vamos utilizar as Etapas anteriormente apresentadas: De uma só vez, conseguimos cumprir as Etapas 1 e 2 com o código abaixo: Etapa 1: Conhecer detalhadamente o caminho para acesso aos dados: no nosso exemplo, o código fonte do endereço virtual que apresenta o discurso também nos apresenta o conteúdo publicado. Etapa 2: Armazenar todos os caminhos de acesso aos dados de forma amigável ao programa: nesse exemplo, trata-se de apenas um endereço que armazenamos no objeto link. # carregando pacotes ---- library(tidyverse) library(rvest) library(httr) library(xml2) # definindo o endereço da web link &lt;- &quot;https://www.camara.leg.br/internet/SitaqWeb/TextoHTML.asp?etapa=5&amp;nuSessao=174.4.53.O&amp;nuQuarto=56&amp;nuOrador=2&amp;nuInsercao=0&amp;dtHorarioQuarto=11:46&amp;sgFaseSessao=BC&amp;Data=17/08/2010&amp;txApelido=JAIR%20BOLSONARO,%20PP-RJ&amp;txFaseSessao=Breves%20Comunica%C3%A7%C3%B5es&amp;txTipoSessao=Extraordin%C3%A1ria%20-%20CD&amp;dtHoraQuarto=11:46&amp;txEtapa=&quot; Etapa 3: Obter os dados: Podemos facilmente obter o código fonte de um endereço na internet com o uso da função readLines. Aplicamos, portanto, a função no objeto link e atribuímos seu resultado ao objeto conteudo. # obtem o codigo fonte conteudo &lt;- readLines(link) Veja que o objeto conteudo é um vetor cujos elementos são cada uma das linhas presentes no código fonte da página. Isso significa que não precisamos mais do acesso à internet ou do próprio endereço para processar o conteúdo obtido uma vez que já está retido no seu ambiente de trabalho no R. Nessa etapa, pode ser conveniente salvar o objeto conteudo em seu formato bruto para posterior tratamento. Etapa 4: Processar os dados obtidos: Para finalizar nossa tarefa, uma rápida análise do objeto conteudo (código fonte da página que publicou o discurso), nos mostra que o elemento 328 do vetor apresenta o conteúdo de interesse. Veja que, nesse caso, a análise do próprio código fonte da página da Câmara dos Deputados apresenta o conteúdo do discurso na linha 328 do código html. Para processar os dados obtidos, vamos selecionar apenas o elemento 328 e assim concluímos nossa missão. conteudo &lt;- conteudo[328] 5.2.4.1 Atividade prática Com base no exemplo acima, obtenha o código fonte da página do Chico Buarque na Wikipédia. 5.3 Web Services Os Web services são utilizados para disponibilizar serviços interativos na Web, podendo ser acessados por outras aplicações. O objetivo dos Web Services é a comunicação de aplicações através da Internet. Um dos motivos que tornam os Web Services atrativos para a obtenção de dados e conteúdo é o fato deste serviço ser desenvolvido com base em tecnologias standards, em particular XML e HTTP (Hypertext Transfer Protocol). 5.3.1 Obtenção de conteúdo via WS - Exemplo: A Câmara dos Deputados do Brasil possui um excelente serviço de transparência. Estimulado pela iniciativa do Laboratório Hacker, foi desenvolvido o Web service da Câmara dos Deputados. Após a realização da Primeira Maratona Hacker da Câmara dos Deputados em 2013, quando fora desenvolvido o Projeto Retórica Parlamentar, o Web Service da CD passou a disponibilizar os discursos proferidos pelos deputados federais em plenário. September 11th - The Washington Post Os ataques terroistas de 11 de setembro de 2001 chocaram o mundo e os deputados federais brasileiros não ficaram em silêncio diante de fato tão relevante. Nossa tarefa será a de obter os dados e o conteúdo dos discursos proferidos nesse dia terrível. Em virtude da estrutura de disponibilização dos dados no WebService da Câmara dos Deputados, nossa tarefa será dividida em duas subtarefas: obter os meta-dados dos discursos; obter o conteúdo dos discursos (inteiror teor). 5.3.2 a) obter os meta-dados dos discursos Vamos utilizar as Etapas anteriormente apresentadas: De uma só vez, conseguimos realizar as Etapas 1 e 2: Etapa 1: Conhecer detalhadamente o caminho para acesso aos dados: Conhecendo exatamente como deve ser a chamada (o endereço que dá acesso aos dados), podemos simplesmente passar os parâmetros. Os parâmetros podem ser encontrados no guia do WebService. No nosso exemplo, temos como parâmetros a data inicial (dataInicial) e a data final (dataFinal) de busca pelos discursos. Sendo nosso objetivo obter os discursos proferidos num mesmo dia, usamos como parâmetros “11/09/2001”. Etapa 2: Armazenar todos os caminhos de acesso aos dados de forma amigável ao programa: Nesse exemplo, trata-se de apenas um endereço que armazenamos no objeto link. # pacotes library(httr) library(XML) library(xml2) library(RCurl) library(tidyverse) library(stringr) # definindo parametros da chamada dataInicial &lt;- &quot;11/09/2001&quot; dataFinal &lt;- &quot;11/09/2001&quot; # alocando enderenço a objeto link link &lt;- paste(&quot;https://www.camara.leg.br/sitcamaraws/SessoesReunioes.asmx/ListarDiscursosPlenario?&quot;, &quot;dataIni=&quot;, dataInicial, &quot;&amp;dataFim=&quot;, dataFinal, &quot;&amp;codigoSessao=&amp;parteNomeParlamentar=&amp;siglaPartido=&amp;siglaUF=&quot;, sep = &quot;&quot;) Etapa 3: Obter os dados: Para essa etapa, basta fazer uso da função GET. No código abaixo, armazenamos os resultados no objeto response. response &lt;- GET(link) Etapa 4: Processar os dados obtidos: Organizar o resultado da função GET num formato de matriz de dados (data.frame) é simples. Primeiro, transformamos o resultado numa lista, na qual cada elemento será uma das sessões legislativas realizadas naquela data. Em segundo lugar, de forma interativa, usando a função for, alocamos os campos desejados num objeto data.frame7. # analisa um arquivo XML ou HTML e gera uma estrutura no R. data &lt;- xmlParse(response, encoding = &quot;UTF-8&quot;) # transforma um XML nó em lista. Importante pois permite você reconhecer o caminho para obtenção dos dados. Exemplo: &quot;$sessao$fasesSessao$faseSessao$discursos$discurso$sumario&quot; ls &lt;- xmlToList(data) # data frame que recebera dados dos pronunciamentos bd &lt;- data.frame() for (i in 1:length(ls)){ # obtendo quantidade de pronunciamentos de uma respectiva sessao quantPronunciamentos &lt;- length(ls[i]$sessao$fasesSessao$faseSessao$discursos) sumario &lt;- vector(&quot;character&quot;) numInsercao &lt;- vector(&quot;character&quot;) numQuarto &lt;- vector(&quot;character&quot;) indexacao &lt;- vector(&quot;character&quot;) hora &lt;- vector(&quot;character&quot;) uf &lt;- vector(&quot;character&quot;) numOrador &lt;- vector(&quot;character&quot;) nomeOrador &lt;- vector(&quot;character&quot;) partido &lt;- vector(&quot;character&quot;) for(j in 1:quantPronunciamentos){ # obtendo todos os dados do pronunciamento # sumario sumario[j] &lt;- str_trim(ls[i]$sessao$fasesSessao$faseSessao$discursos[[j]]$sumario) # insercao numInsercao[j] &lt;- str_trim(ls[i]$sessao$fasesSessao$faseSessao$discursos[[j]]$numeroInsercao) # quarto numQuarto[j] &lt;- str_trim(ls[i]$sessao$fasesSessao$faseSessao$discursos[[j]]$numeroQuarto) # indexacao indexacao[j] &lt;- str_trim(ls[i]$sessao$fasesSessao$faseSessao$discursos[[j]]$txtIndexacao) # hora hora[j] &lt;- str_trim(ls[i]$sessao$fasesSessao$faseSessao$discursos[[j]]$horaInicioDiscurso) # uf orador uf[j] &lt;- str_trim(ls[i]$sessao$fasesSessao$faseSessao$discursos[[j]]$orador$uf) # numero orador numOrador[j] &lt;- str_trim(ls[i]$sessao$fasesSessao$faseSessao$discursos[[j]]$orador$numero) # nome orador nomeOrador[j] &lt;- str_trim(ls[i]$sessao$fasesSessao$faseSessao$discursos[[j]]$orador$nome) # partido orador partido[j] &lt;- str_trim(ls[i]$sessao$fasesSessao$faseSessao$discursos[[j]]$orador$partido) } # obtendo todos os dados da fase # codigo codigoFase &lt;- str_trim(ls[i]$sessao$fasesSessao$faseSessao$codigo) # descricao descricaoFase &lt;- str_trim(ls[i]$sessao$fasesSessao$faseSessao$descricao) # obtendo todos os dados da sessao # codigo codigoSessao &lt;- str_trim(ls[i]$sessao$codigo) # data dataSessao &lt;- str_trim(ls[i]$sessao$data) # numero numSessao &lt;- str_trim(ls[i]$sessao$numero) # tipo tipoSessao &lt;- str_trim(ls[i]$sessao$tipo) bdTemp &lt;- data.frame(codigoSessao = rep(codigoSessao, length(nomeOrador)), dataSessao = rep(dataSessao, length(nomeOrador)), numSessao = rep(numSessao, length(nomeOrador)), tipoSessao = rep(tipoSessao, length(nomeOrador)), codigoFase = rep(codigoFase, length(nomeOrador)), descricaoFase = rep(descricaoFase, length(nomeOrador)), numInsercao = numInsercao, numQuarto = numQuarto, hora = hora, numOrador = numOrador, nomeOrador = nomeOrador, uf = uf, partido = partido, indexacao = indexacao, sumario = sumario) bd &lt;- rbind(bd, bdTemp) } Com o objeto bd acima, concluímos a primeira subetapa e podemos seguir para a segunda. 5.3.3 b) obter o conteúdo dos discursos (inteiror teor).** Importante ressaltar que essa etapa só é possível tendo realizado o método acima de ListarDiscursosPlenário, devido exigência do próprio WebService. bdDados &lt;- bd bd &lt;- data.frame() # data frame que recebera os pronunciamentos for( i in 1:dim(bdDados)[1]){ link &lt;- paste(&quot;https://www.camara.leg.br/SitCamaraWS/SessoesReunioes.asmx/obterInteiroTeorDiscursosPlenario?&quot;, &quot;codSessao=&quot;, bdDados$codigoSessao[i], &quot;&amp;numOrador=&quot;, bdDados$numOrador[i], &quot;&amp;numQuarto=&quot;, bdDados$numQuarto[i], &quot;&amp;numInsercao=&quot;, bdDados$numInsercao[i], sep = &quot;&quot;) print(link) response &lt;- GET(link) data &lt;- xmlParse(response, encoding = &quot;UTF-8&quot;) ls &lt;- xmlToList(data) bdTemp &lt;- data.frame(nome = ls$nome, partido = ls$partido, uf = ls$uf, horaInicioDiscurso = ls$horaInicioDiscurso, discursoRTFBase64 = ls$discursoRTFBase64) bd &lt;- rbind(bd, bdTemp) Sys.sleep(.5) } Obtivemos os discursos em seu inteiro teor! No entanto, os dados estão em formato RTF codificado em Base64. Precisamos transformá-los em formato de texto plano para possibilitar sua leitura: bd$discursoRTFBase64 &lt;- as.character(bd$discursoRTFBase64) bd$discursoPlainTxt &lt;- vector(mode = &quot;character&quot;, length = dim(bd)[1]) for (i in 1:dim(bd)[1]){ bd$discursoPlainTxt[i] &lt;- decode_rtf(bd$discursoRTFBase64[i]) print( bd$discursoPlainTxt) } 5.3.3.1 Atividade prática Utilizando o código acima, obtenha as falas proferidas do dia da autorização do processo de impeachement da Presidenta Dilma Vana Rousseff na Câmara dos Deputados, ocorrido em 17 de abril de 2016. Salve os dados em formato .rda. 5.4 Download de arquivos da web Além do conteúdo diretamente publicado numa página web, pode ser de interesse fazer o download de arquivos disponíveis. Em especial, no caso brasileiro, muitos órgãos públicos publicam relatórios em formato .pdf. O obstáculo proporcionado pelo formato do arquivo e o modo como o conteúdo é disponibilizado pode ser superado com o uso da linguagem R. Como exemplo, vamos conferir o caso do Tribunal de Contas do Estado de Pernambuco, que anualmente disponibiliza relatórios de gestão. TCE-PE Para atingir nosso objetivo, vamos utilizar as Etapas anteriormente apresentadas: Etapa 1: Conhecer detalhadamente o caminho para acesso aos dados: A página do TCE-PE apresenta os relatórios publicados anualmente. library(rvest) library(XML) library(xml2) link_tce &lt;- &quot;https://www.tce.pe.gov.br/internet/index.php/relatorios-de-gestao-fiscal-2&quot; Etapa 2: Armazenar todos os caminhos de acesso aos dados de forma amigável ao programa: Aqui selecionamos exatamente os endereços de download de cada um dos arquivos publicados. Todos os .pdf são um link dentro do código fonte da página, iremos, portanto, obter os links desses relatórios. Para tanto, podemos observar que o código fonte possui um padrão que identifica os Relatórios de Desempenho anual: rdg. Iremos utilizá-lo para obter somente os documentos que possuam esse padrão. link_relatorios &lt;- link_tce %&gt;% read_html %&gt;% # função que irá ler o código fonte escrito em html html_nodes(&quot;a&quot;) %&gt;% # nó presente no código fonte antes do pdf html_attr(&quot;href&quot;) # atributro do nó # obtenção dos links do relatório através do padrão `rgd` link_relatorios &lt;- link_relatorios[grep(&quot;rdg&quot;, link_relatorios)] Etapa 3: Obter os dados: A obtenção dos dados se refere justamente ao download do material para armazenamento local. Logo, definimos o diretório onde os arquivos serão salvos e fazemos uso da função download.file. Como obtivemos mais de um link, para mais de um relatório, no código abaixo apresentamos como obter o primeiro arquivo .pdf presente em link_relatorios[1]. download.file(link_relatorios[1], destfile = &quot;seu_diretorio/nome_do_arquivo.pdf&quot;, mode = &quot;wb&quot;) Etapa 4: Processar os dados obtidos: O processo é similar à leitura de conteúdo em arquivo .pdf explicada na seção ??. # pacotes library(textreadr) library(here) # # lendo arquivo .pdf rdg2018 &lt;- read_document(&quot;nome_arquivo.pdf&quot;) # salvando como .txt writeLines(rdg2018, &quot;meu_arquivo.txt&quot;) 5.5 Twitter Existem diversos pacotes que possibilitam a captura de informação do Twitter, sendo possível obter tweets ou timelines somente de usuários públicos, ou seja que não possuem um perfil privado. Como exemplo, vamos utilizar o pacote rtweet para obter dados dos tweets da timeline da Deputada Federal Tabata Amaral. Vale ressaltar que o Twitter exige que para obtenção dos dados você possua uma conta no Twitter e autorize o app rstats2twitter no popup que surgirá no seu browser ao utilizar alguma das funções no console do R, isso ocorrerá somente na primeira vez de uso, criando um token que será salvo para próximas sessões. library(rtweet) tabata_timeline &lt;- get_timeline( user = &quot;tabataamaralsp&quot;, n = 30) Além do uso de obtenção de hashtags é possível buscar termos que estão sendo tweetados ou hashtags através do search_tweets que segue lógica similar ao get_timeline. 5.6 Imagens No caso de textos em imagem é possível utilizar o optical character recognition (OCR). OCR é o processo de encontrar e reconhecer texto dentro de imagens, por exemplo, de uma captura de tela, texto digitalizado, etc. A imagem abaixo tem um texto de exemplo: ocr Com o pacote Tesseract e o uso da Interface de Programação de Aplicativos (API) do Google é possível capturar seu conteúdo, podendo ser uma imagem presente no seu computador ou da web. Para realizá-lo em português é necessário instalar o acervo de treinamento em português com o seguinte comando tesseract_download('por'). No caso, vamos utilizar a imagem do Tweet Fake atribuído ao Presidente Bolsonaro para obter seu conteúdo: FAKE NEWS! library(tesseract) # obtendo treinamento na ligua portuguesa tesseract_download(&#39;por&#39;) por &lt;- tesseract(&quot;por&quot;) # alocando treinamento na ligua portuguesa # obtendo texto da imagem text &lt;- tesseract::ocr(&quot;https://raw.githubusercontent.com/davi-moreira/txt4cs/master/images/tweet_bolsonaro_cp.png&quot;, engine = por) # resultado cat(text) Segue o resultado: ## Jair M. Bolsonaro &amp; 8 a Qjairbolsonaro Vie . S O que é ciência política? 09:26 - 06/03/2019 - Twitter for iPhone 5.7 Áudio Transcrição EM CONSTRUÇÃO……….. Conteúdo publicado pela Câmara dos Deputados sem revisão do autor.↩ Conteúdo publicado pela Câmara dos Deputados sem revisão do autor.↩ Para uma referência de como transformar objetos xml em data.frame ver: i) (https://stackoverflow.com/questions/17198658/how-to-parse-xml-to-r-data-frame); ii) (https://stackoverflow.com/questions/13579996/how-to-create-an-r-data-frame-from-a-xml-file)↩ "],
["processamento.html", "Capítulo 6 Processamento dos dados 6.1 Tokens 6.2 Corpus 6.3 Tokens e Corpus 6.4 DFM: Matriz de documentos e termos 6.5 Stemming 6.6 FCM: Matriz de co-ocorrência de termos", " Capítulo 6 Processamento dos dados EM CONSTRUÇÃO… 6.1 Tokens 6.2 Corpus 6.3 Tokens e Corpus 6.4 DFM: Matriz de documentos e termos 6.5 Stemming 6.6 FCM: Matriz de co-ocorrência de termos "],
["stat.html", "Capítulo 7 Mineração e estatísticas básicas 7.1 Análise de frequência 7.2 Nuvem de palavras 7.3 tf-idf 7.4 Rede de n-grams 7.5 Correlação pareada 7.6 Diversidade lexical 7.7 Similaridade entre documentos/termos 7.8 KEYNESS: Análise de Frequência Relativa", " Capítulo 7 Mineração e estatísticas básicas EM CONSTRUÇÃO… 7.1 Análise de frequência 7.2 Nuvem de palavras 7.3 tf-idf 7.4 Rede de n-grams 7.5 Correlação pareada 7.6 Diversidade lexical 7.7 Similaridade entre documentos/termos 7.8 KEYNESS: Análise de Frequência Relativa "],
["scalling.html", "Capítulo 8 Escalonamento 8.1 Wordscore 8.2 Wordfish", " Capítulo 8 Escalonamento EM CONSTRUÇÃO… 8.1 Wordscore 8.2 Wordfish "],
["classificacao.html", "Capítulo 9 Classificação 9.1 Método de dicionário: Análise de sentimento 9.2 Naive Bayes 9.3 LDA: Latent Dirichlet Allocation 9.4 STM: Structed Topic Model", " Capítulo 9 Classificação EM CONSTRUÇÃO… 9.1 Método de dicionário: Análise de sentimento 9.2 Naive Bayes 9.3 LDA: Latent Dirichlet Allocation 9.4 STM: Structed Topic Model "],
["referências.html", "Referências", " Referências "]
]
